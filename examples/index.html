
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta property="og:title" content="Example pages" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://myst-parser.readthedocs.io/en/examples/index.html" />
  <meta property="og:description" content="MyST brings all of the features of reStructuredText into markdown. As an example, The pages below have the same final product, but are written in either reStructuredText or MyST markdown. You can b..." />
  <meta property="og:image" content="https://repository-images.githubusercontent.com/240151150/316bc480-cc23-11eb-96fc-4ab2f981a65d" />
  <meta property="og:image:alt" content="Example pages" />
  <meta name="twitter:card" content="summary_large_image">
    <title>Example pages</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
    <link rel="shortcut icon" href="../_static/logo-square.svg"/>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="Wealth Distribution Dynamics in rST" href="wealth_dynamics_rst.html" />
    <link rel="prev" title="Testing Infrastructure" href="../develop/test_infrastructure.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="zh_CN">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo-wide.svg" class="logo" alt="logo">
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../sphinx/intro.html">
   在 Sphinx 中开始使用 MyST
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  MyST 语法
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../syntax/syntax.html">
   The MyST Syntax Guide
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../syntax/optional.html">
   Optional MyST Syntaxes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../syntax/reference.html">
   MyST Syntax Reference
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  主题指南
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../explain/index.html">
   Background and explanation
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../sphinx/index.html">
   含 Sphinx 的 MyST
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../sphinx/use.html">
     Sphinx extension usage guide
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../sphinx/roles-and-directives.html">
     Special roles and directives
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../sphinx/reference.html">
     Sphinx configuration options
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../sphinx/faq.html">
     Common errors and questions
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../api/index.html">
   MyST-Parser Python API
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../api/parsers.html">
     Parse MyST Markdown
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../api/renderers.html">
     Render outputs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../api/reference.html">
     API Reference
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../develop/index.html">
   Contribute to MyST
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../develop/contributing.html">
     Contributing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../develop/architecture.html">
     The MyST implementation architecture
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../develop/test_infrastructure.html">
     Testing Infrastructure
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  关于
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active has-children">
  <a class="current reference internal" href="#">
   Example pages
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="wealth_dynamics_rst.html">
     Wealth Distribution Dynamics in rST
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="wealth_dynamics_md.html">
     Wealth Distribution Dynamics in MyST
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../develop/_changelog.html">
   Changelog
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference external" href="https://github.com/executablebooks/myst-parser">
   GitHub 仓库
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/examples/index.md.txt"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        
        
        <a class="edit-button" href="https://github.com/daobook/MyST-Parser/edit/master/docs/examples/index.md"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#raw-content-of-each-document-above">
   Raw content of each document above
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="example-pages">
<h1>Example pages<a class="headerlink" href="#example-pages" title="永久链接至标题">¶</a></h1>
<p>MyST brings all of the features of reStructuredText into markdown. As an example,
The pages below have the same final product, but are written in either reStructuredText
or MyST markdown. You can browse the raw content of each page by clicking the
“download” button at the top of each page, or see the raw content below.</p>
<div class="toctree-wrapper compound">
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Compare rST and MyST versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="wealth_dynamics_rst.html">Wealth Distribution Dynamics in rST</a></li>
<li class="toctree-l1"><a class="reference internal" href="wealth_dynamics_md.html">Wealth Distribution Dynamics in MyST</a></li>
</ul>
</div>
<div class="section" id="raw-content-of-each-document-above">
<h2>Raw content of each document above<a class="headerlink" href="#raw-content-of-each-document-above" title="永久链接至标题">¶</a></h2>
<p>The following tabs show the raw content of each of the above documents, for quick
comparison.</p>
<div class="tabbed-set docutils">
<input checked="checked" id="b2c936de-8b58-488f-8be3-80f9df272bf2" name="e1e0d094-08ed-4175-a666-cb007f6ccdb6" type="radio">
</input><label class="tabbed-label" for="b2c936de-8b58-488f-8be3-80f9df272bf2">
MyST Markdown</label><div class="tabbed-content docutils">
<p>Raw source for <a class="reference internal" href="wealth_dynamics_md.html"><span class="doc">Wealth Distribution Dynamics in MyST</span></a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># Wealth Distribution Dynamics in MyST

&gt; {sub-ref}`today` | {sub-ref}`wordcount-minutes` min read

```{note}
You can {download}`Download the source file for this page &lt;./wealth_dynamics_md.md&gt;`
```

```{contents}
:depth: 2
```

In addition to what&#39;s in Anaconda, this lecture will need the following
libraries:

```{code-block} ipython
---
class: hide-output
---
!pip install --upgrade quantecon
```

## Overview

This notebook gives an introduction to wealth distribution dynamics,
with a focus on

- modeling and computing the wealth distribution via simulation,
- measures of inequality such as the Lorenz curve and Gini
    coefficient, and
- how inequality is affected by the properties of wage income and
    returns on assets.

The wealth distribution in many countries exhibits a Pareto tail

- See {doc}`this lecture &lt;heavy_tails&gt;` for a
    definition.
- For a review of the empirical evidence, see, for example,
    {cite}`md-benhabib2018skewed`.

### A Note on Assumptions

The evolution of wealth for any given household depends on their savings
behavior.

We will use the following imports.

```{code-block} python
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

import quantecon as qe
from numba import njit, jitclass, float64, prange
```

## Lorenz Curves and the Gini Coefficient

Before we investigate wealth dynamics, we briefly review some measures
of inequality.

### Lorenz Curves

One popular graphical measure of inequality is the [Lorenz curve](https://en.wikipedia.org/wiki/Lorenz_curve).

The package [QuantEcon.py](https://github.com/QuantEcon/QuantEcon.py),
already imported above, contains a function to compute Lorenz curves.

To illustrate, suppose that

```{code-block} python
n = 10_000                      # size of sample
w = np.exp(np.random.randn(n))  # lognormal draws
```

is data representing the wealth of 10,000 households.

We can compute and plot the Lorenz curve as follows:

```{code-block} python
f_vals, l_vals = qe.lorenz_curve(w)

fig, ax = plt.subplots()
ax.plot(f_vals, l_vals, label=&#39;Lorenz curve, lognormal sample&#39;)
ax.plot(f_vals, f_vals, label=&#39;Lorenz curve, equality&#39;)
ax.legend()
plt.show()
```

This curve can be understood as follows: if point $(x,y)$ lies on the
curve, it means that, collectively, the bottom $(100x)\%$ of the
population holds $(100y)\%$ of the wealth.

```{code-block} python
a_vals = (1, 2, 5)              # Pareto tail index
n = 10_000                      # size of each sample
fig, ax = plt.subplots()
for a in a_vals:
    u = np.random.uniform(size=n)
    y = u**(-1/a)               # distributed as Pareto with tail index a
    f_vals, l_vals = qe.lorenz_curve(y)
    ax.plot(f_vals, l_vals, label=f&#39;$a = {a}$&#39;)
ax.plot(f_vals, f_vals, label=&#39;equality&#39;)
ax.legend()
plt.show()
```

You can see that, as the tail parameter of the Pareto distribution
increases, inequality decreases.

This is to be expected, because a higher tail index implies less weight
in the tail of the Pareto distribution.

### The Gini Coefficient

The definition and interpretation of the Gini coefficient can be found
on the corresponding [Wikipedia page](https://en.wikipedia.org/wiki/Gini\_coefficient).

A value of 0 indicates perfect equality (corresponding the case where
the Lorenz curve matches the 45 degree line) and a value of 1 indicates
complete inequality (all wealth held by the richest household).

The [QuantEcon.py](https://github.com/QuantEcon/QuantEcon.py) library
contains a function to calculate the Gini coefficient.

We can test it on the Weibull distribution with parameter $a$, where the
Gini coefficient is known to be

$$G = 1 - 2^{-1/a}$$

Let&#39;s see if the Gini coefficient computed from a simulated sample
matches this at each fixed value of $a$.

```{code-block} python
a_vals = range(1, 20)
ginis = []
ginis_theoretical = []
n = 100

fig, ax = plt.subplots()
for a in a_vals:
    y = np.random.weibull(a, size=n)
    ginis.append(qe.gini_coefficient(y))
    ginis_theoretical.append(1 - 2**(-1/a))
ax.plot(a_vals, ginis, label=&#39;estimated gini coefficient&#39;)
ax.plot(a_vals, ginis_theoretical, label=&#39;theoretical gini coefficient&#39;)
ax.legend()
ax.set_xlabel(&quot;Weibull parameter $a$&quot;)
ax.set_ylabel(&quot;Gini coefficient&quot;)
plt.show()
```

The simulation shows that the fit is good.

## A Model of Wealth Dynamics

Having discussed inequality measures, let us now turn to wealth
dynamics.

The model we will study is

```{math}
---
label: md:wealth_dynam_ah
---
w_{t+1} = (1 + r_{t+1}) s(w_t) + y_{t+1}
```

where

- $w_t$ is wealth at time $t$ for a given household,
- $r_t$ is the rate of return of financial assets,
- $y_t$ is current non-financial (e.g., labor) income and
- $s(w_t)$ is current wealth net of consumption

Letting $\{z_t\}$ be a correlated state process of the form

$$z_{t+1} = a z_t + b + \sigma_z \epsilon_{t+1}$$

we&#39;ll assume that

$$R_t := 1 + r_t = c_r \exp(z_t) + \exp(\mu_r + \sigma_r \xi_t)$$

and

$$y_t = c_y \exp(z_t) + \exp(\mu_y + \sigma_y \zeta_t)$$

Here $\{ (\epsilon_t, \xi_t, \zeta_t) \}$ is IID and standard normal in
$\mathbb R^3$.

(md:sav_ah)=

```{math}
---
label: md:sav_ah
---
s(w) = s_0 w \cdot \mathbb 1\{w \geq \hat w\}
```


where $s_0$ is a positive constant.

## Implementation

Here&#39;s some type information to help Numba.

```{code-block} python
wealth_dynamics_data = [
    (&#39;w_hat&#39;,  float64),    # savings parameter
    (&#39;s_0&#39;,    float64),    # savings parameter
    (&#39;c_y&#39;,    float64),    # labor income parameter
    (&#39;μ_y&#39;,    float64),    # labor income paraemter
    (&#39;σ_y&#39;,    float64),    # labor income parameter
    (&#39;c_r&#39;,    float64),    # rate of return parameter
    (&#39;μ_r&#39;,    float64),    # rate of return parameter
    (&#39;σ_r&#39;,    float64),    # rate of return parameter
    (&#39;a&#39;,      float64),    # aggregate shock parameter
    (&#39;b&#39;,      float64),    # aggregate shock parameter
    (&#39;σ_z&#39;,    float64),    # aggregate shock parameter
    (&#39;z_mean&#39;, float64),    # mean of z process
    (&#39;z_var&#39;, float64),     # variance of z process
    (&#39;y_mean&#39;, float64),    # mean of y process
    (&#39;R_mean&#39;, float64)     # mean of R process
]
```

Here&#39;s a class that stores instance data and implements methods that
update the aggregate state and household wealth.

```{code-block} python
@jitclass(wealth_dynamics_data)
class WealthDynamics:

    def __init__(self,
                 w_hat=1.0,
                 s_0=0.75,
                 c_y=1.0,
                 μ_y=1.0,
                 σ_y=0.2,
                 c_r=0.05,
                 μ_r=0.1,
                 σ_r=0.5,
                 a=0.5,
                 b=0.0,
                 σ_z=0.1):

        self.w_hat, self.s_0 = w_hat, s_0
        self.c_y, self.μ_y, self.σ_y = c_y, μ_y, σ_y
        self.c_r, self.μ_r, self.σ_r = c_r, μ_r, σ_r
        self.a, self.b, self.σ_z = a, b, σ_z

        # Record stationary moments
        self.z_mean = b / (1 - a)
        self.z_var = σ_z**2 / (1 - a**2)
        exp_z_mean = np.exp(self.z_mean + self.z_var / 2)
        self.R_mean = c_r * exp_z_mean + np.exp(μ_r + σ_r**2 / 2)
        self.y_mean = c_y * exp_z_mean + np.exp(μ_y + σ_y**2 / 2)

        # Test a stability condition that ensures wealth does not diverge
        # to infinity.
        α = self.R_mean * self.s_0
        if α &gt;= 1:
            raise ValueError(&quot;Stability condition failed.&quot;)

    def parameters(self):
        &quot;&quot;&quot;
        Collect and return parameters.
        &quot;&quot;&quot;
        parameters = (self.w_hat, self.s_0,
                      self.c_y, self.μ_y, self.σ_y,
                      self.c_r, self.μ_r, self.σ_r,
                      self.a, self.b, self.σ_z)
        return parameters

    def update_states(self, w, z):
        &quot;&quot;&quot;
        Update one period, given current wealth w and persistent
        state z.
        &quot;&quot;&quot;

        # Simplify names
        params = self.parameters()
        w_hat, s_0, c_y, μ_y, σ_y, c_r, μ_r, σ_r, a, b, σ_z = params
        zp = a * z + b + σ_z * np.random.randn()

        # Update wealth
        y = c_y * np.exp(zp) + np.exp(μ_y + σ_y * np.random.randn())
        wp = y
        if w &gt;= w_hat:
            R = c_r * np.exp(zp) + np.exp(μ_r + σ_r * np.random.randn())
            wp += R * s_0 * w
        return wp, zp
```

Here&#39;s function to simulate the time series of wealth for in individual
households.

```{code-block} python
@njit
def wealth_time_series(wdy, w_0, n):
    &quot;&quot;&quot;
    Generate a single time series of length n for wealth given
    initial value w_0.

    The initial persistent state z_0 for each household is drawn from
    the stationary distribution of the AR(1) process.

        * wdy: an instance of WealthDynamics
        * w_0: scalar
        * n: int


    &quot;&quot;&quot;
    z = wdy.z_mean + np.sqrt(wdy.z_var) * np.random.randn()
    w = np.empty(n)
    w[0] = w_0
    for t in range(n-1):
        w[t+1], z = wdy.update_states(w[t], z)
    return w
```

Now here&#39;s function to simulate a cross section of households forward
in time.

Note the use of parallelization to speed up computation.

```{code-block} python
@njit(parallel=True)
def update_cross_section(wdy, w_distribution, shift_length=500):
    &quot;&quot;&quot;
    Shifts a cross-section of household forward in time

    * wdy: an instance of WealthDynamics
    * w_distribution: array_like, represents current cross-section

    Takes a current distribution of wealth values as w_distribution
    and updates each w_t in w_distribution to w_{t+j}, where
    j = shift_length.

    Returns the new distribution.

    &quot;&quot;&quot;
    new_distribution = np.empty_like(w_distribution)

    # Update each household
    for i in prange(len(new_distribution)):
        z = wdy.z_mean + np.sqrt(wdy.z_var) * np.random.randn()
        w = w_distribution[i]
        for t in range(shift_length-1):
            w, z = wdy.update_states(w, z)
        new_distribution[i] = w
    return new_distribution
```

Parallelization is very effective in the function above because the time
path of each household can be calculated independently once the path for
the aggregate state is known.

## Applications

Let&#39;s try simulating the model at different parameter values and
investigate the implications for the wealth distribution.

### Time Series

Let&#39;s look at the wealth dynamics of an individual household.

```{code-block} python
wdy = WealthDynamics()

ts_length = 200
w = wealth_time_series(wdy, wdy.y_mean, ts_length)

fig, ax = plt.subplots()
ax.plot(w)
plt.show()
```

Notice the large spikes in wealth over time.

Such spikes are similar to what we observed in time series when
{doc}`we studied Kesten processes&lt;kesten_processes&gt;`.

### Inequality Measures

Let&#39;s look at how inequality varies with returns on financial assets.

The next function generates a cross section and then computes the Lorenz
curve and Gini coefficient.

```{code-block} python
def generate_lorenz_and_gini(wdy, num_households=100_000, T=500):
    &quot;&quot;&quot;
    Generate the Lorenz curve data and gini coefficient corresponding to a
    WealthDynamics mode by simulating num_households forward to time T.
    &quot;&quot;&quot;
    ψ_0 = np.ones(num_households) * wdy.y_mean
    z_0 = wdy.z_mean

    ψ_star = update_cross_section(wdy, ψ_0, shift_length=T)
    return qe.gini_coefficient(ψ_star), qe.lorenz_curve(ψ_star)
```

Now we investigate how the Lorenz curves associated with the wealth
distribution change as return to savings varies.

The code below plots Lorenz curves for three different values of $\mu_r$.

If you are running this yourself, note that it will take one or two
minutes to execute.

This is unavoidable because we are executing a CPU intensive task.

In fact the code, which is JIT compiled and parallelized, runs extremely
fast relative to the number of computations.

```{code-block} python
fig, ax = plt.subplots()
μ_r_vals = (0.0, 0.025, 0.05)
gini_vals = []

for μ_r in μ_r_vals:
    wdy = WealthDynamics(μ_r=μ_r)
    gv, (f_vals, l_vals) = generate_lorenz_and_gini(wdy)
    ax.plot(f_vals, l_vals, label=f&#39;$\psi^*$ at $\mu_r = {μ_r:0.2}$&#39;)
    gini_vals.append(gv)

ax.plot(f_vals, f_vals, label=&#39;equality&#39;)
ax.legend(loc=&quot;upper left&quot;)
plt.show()
```

The Lorenz curve shifts downwards as returns on financial income rise,
indicating a rise in inequality.

(htop_again)=

```{image} htop_again.png
---
scale: 80
---
```

Now let&#39;s check the Gini coefficient.

```{code-block} python
fig, ax = plt.subplots()
ax.plot(μ_r_vals, gini_vals, label=&#39;gini coefficient&#39;)
ax.set_xlabel(&quot;$\mu_r$&quot;)
ax.legend()
plt.show()
```

Once again, we see that inequality increases as returns on financial
income rise.

Let&#39;s finish this section by investigating what happens when we change
the volatility term $\sigma_r$ in financial returns.

```{code-block} python
fig, ax = plt.subplots()
σ_r_vals = (0.35, 0.45, 0.52)
gini_vals = []

for σ_r in σ_r_vals:
    wdy = WealthDynamics(σ_r=σ_r)
    gv, (f_vals, l_vals) = generate_lorenz_and_gini(wdy)
    ax.plot(f_vals, l_vals, label=f&#39;$\psi^*$ at $\sigma_r = {σ_r:0.2}$&#39;)
    gini_vals.append(gv)

ax.plot(f_vals, f_vals, label=&#39;equality&#39;)
ax.legend(loc=&quot;upper left&quot;)
plt.show()
```

We see that greater volatility has the effect of increasing inequality
in this model.

```{bibliography} references.bib
:labelprefix: md
:keyprefix: md-
```
</pre></div>
</div>
</div>
<input id="6be7521e-0820-4835-b250-978615abd489" name="e1e0d094-08ed-4175-a666-cb007f6ccdb6" type="radio">
</input><label class="tabbed-label" for="6be7521e-0820-4835-b250-978615abd489">
reStructuredText</label><div class="tabbed-content docutils">
<p>Raw source for <a class="reference internal" href="wealth_dynamics_rst.html"><span class="doc">Wealth Distribution Dynamics in rST</span></a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>.. highlight:: python3


***********************************
Wealth Distribution Dynamics in rST
***********************************


.. note::

    You can
    :download:`Download the source file for this page &lt;./wealth_dynamics_rst.rst&gt;`

.. contents:: :depth: 2

In addition to what&#39;s in Anaconda, this lecture will need the following libraries:

.. code-block:: ipython
  :class: hide-output

  !pip install --upgrade quantecon


Overview
========

This notebook gives an introduction to wealth distribution dynamics, with a
focus on

* modeling and computing the wealth distribution via simulation,

* measures of inequality such as the Lorenz curve and Gini coefficient, and

* how inequality is affected by the properties of wage income and returns on assets.

The wealth distribution in many countries exhibits a Pareto tail

* See :doc:`this lecture &lt;heavy_tails&gt;` for a definition.

* For a review of the empirical evidence, see, for example, :cite:`benhabib2018skewed`.



A Note on Assumptions
---------------------

The evolution of wealth for any given household depends on their
savings behavior.

We will use the following imports.

.. code:: ipython3

    import numpy as np
    import matplotlib.pyplot as plt
    %matplotlib inline

    import quantecon as qe
    from numba import njit, jitclass, float64, prange


Lorenz Curves and the Gini Coefficient
======================================

Before we investigate wealth dynamics, we briefly review some measures of
inequality.

Lorenz Curves
-------------

One popular graphical measure of inequality is the `Lorenz curve
&lt;https://en.wikipedia.org/wiki/Lorenz_curve&gt;`__.

The package `QuantEcon.py &lt;https://github.com/QuantEcon/QuantEcon.py&gt;`__,
already imported above, contains a function to compute Lorenz curves.

To illustrate, suppose that

.. code:: ipython3

    n = 10_000                      # size of sample
    w = np.exp(np.random.randn(n))  # lognormal draws

is data representing the wealth of 10,000 households.

We can compute and plot the Lorenz curve as follows:

.. code:: ipython3

    f_vals, l_vals = qe.lorenz_curve(w)

    fig, ax = plt.subplots()
    ax.plot(f_vals, l_vals, label=&#39;Lorenz curve, lognormal sample&#39;)
    ax.plot(f_vals, f_vals, label=&#39;Lorenz curve, equality&#39;)
    ax.legend()
    plt.show()

This curve can be understood as follows: if point :math:`(x,y)` lies on the curve, it means that, collectively, the bottom :math:`(100x)\%` of the population holds :math:`(100y)\%` of the wealth.


.. code:: ipython3

    a_vals = (1, 2, 5)              # Pareto tail index
    n = 10_000                      # size of each sample
    fig, ax = plt.subplots()
    for a in a_vals:
        u = np.random.uniform(size=n)
        y = u**(-1/a)               # distributed as Pareto with tail index a
        f_vals, l_vals = qe.lorenz_curve(y)
        ax.plot(f_vals, l_vals, label=f&#39;$a = {a}$&#39;)
    ax.plot(f_vals, f_vals, label=&#39;equality&#39;)
    ax.legend()
    plt.show()

You can see that, as the tail parameter of the Pareto distribution increases, inequality decreases.

This is to be expected, because a higher tail index implies less weight in the tail of the Pareto distribution.



The Gini Coefficient
--------------------

The definition and interpretation of the Gini coefficient can be found on the
corresponding `Wikipedia page
&lt;https://en.wikipedia.org/wiki/Gini_coefficient&gt;`__.

A value of 0 indicates perfect equality (corresponding the case where the
Lorenz curve matches the 45 degree line) and a value of 1 indicates complete
inequality (all wealth held by the richest household).

The `QuantEcon.py &lt;https://github.com/QuantEcon/QuantEcon.py&gt;`__ library
contains a function to calculate the Gini coefficient.

We can test it on the Weibull distribution with parameter :math:`a`, where the
Gini coefficient is known to be

.. math::  G = 1 - 2^{-1/a}

Let&#39;s see if the Gini coefficient computed from a simulated sample matches
this at each fixed value of :math:`a`.



.. code:: ipython3

    a_vals = range(1, 20)
    ginis = []
    ginis_theoretical = []
    n = 100

    fig, ax = plt.subplots()
    for a in a_vals:
        y = np.random.weibull(a, size=n)
        ginis.append(qe.gini_coefficient(y))
        ginis_theoretical.append(1 - 2**(-1/a))
    ax.plot(a_vals, ginis, label=&#39;estimated gini coefficient&#39;)
    ax.plot(a_vals, ginis_theoretical, label=&#39;theoretical gini coefficient&#39;)
    ax.legend()
    ax.set_xlabel(&quot;Weibull parameter $a$&quot;)
    ax.set_ylabel(&quot;Gini coefficient&quot;)
    plt.show()

The simulation shows that the fit is good.



A Model of Wealth Dynamics
==========================

Having discussed inequality measures, let us now turn to wealth dynamics.

The model we will study is

.. math::
    :label: wealth_dynam_ah

    w_{t+1} = (1 + r_{t+1}) s(w_t) + y_{t+1}

where

-  :math:`w_t` is wealth at time :math:`t` for a given household,
-  :math:`r_t` is the rate of return of financial assets,
-  :math:`y_t` is current non-financial (e.g., labor) income and
-  :math:`s(w_t)` is current wealth net of consumption

Letting :math:`\{z_t\}` be a correlated state process of the form

.. math::  z_{t+1} = a z_t + b + \sigma_z \epsilon_{t+1}

we’ll assume that

.. math::  R_t := 1 + r_t = c_r \exp(z_t) + \exp(\mu_r + \sigma_r \xi_t)

and

.. math::  y_t = c_y \exp(z_t) + \exp(\mu_y + \sigma_y \zeta_t)

Here :math:`\{ (\epsilon_t, \xi_t, \zeta_t) \}` is IID and standard
normal in :math:`\mathbb R^3`.


.. math::
    :label: sav_ah

    s(w) = s_0 w \cdot \mathbb 1\{w \geq \hat w\}

where :math:`s_0` is a positive constant.


Implementation
==============

Here&#39;s some type information to help Numba.

.. code:: ipython3

    wealth_dynamics_data = [
        (&#39;w_hat&#39;,  float64),    # savings parameter
        (&#39;s_0&#39;,    float64),    # savings parameter
        (&#39;c_y&#39;,    float64),    # labor income parameter
        (&#39;μ_y&#39;,    float64),    # labor income paraemter
        (&#39;σ_y&#39;,    float64),    # labor income parameter
        (&#39;c_r&#39;,    float64),    # rate of return parameter
        (&#39;μ_r&#39;,    float64),    # rate of return parameter
        (&#39;σ_r&#39;,    float64),    # rate of return parameter
        (&#39;a&#39;,      float64),    # aggregate shock parameter
        (&#39;b&#39;,      float64),    # aggregate shock parameter
        (&#39;σ_z&#39;,    float64),    # aggregate shock parameter
        (&#39;z_mean&#39;, float64),    # mean of z process
        (&#39;z_var&#39;, float64),     # variance of z process
        (&#39;y_mean&#39;, float64),    # mean of y process
        (&#39;R_mean&#39;, float64)     # mean of R process
    ]

Here&#39;s a class that stores instance data and implements methods that update
the aggregate state and household wealth.

.. code:: ipython3

    @jitclass(wealth_dynamics_data)
    class WealthDynamics:

        def __init__(self,
                     w_hat=1.0,
                     s_0=0.75,
                     c_y=1.0,
                     μ_y=1.0,
                     σ_y=0.2,
                     c_r=0.05,
                     μ_r=0.1,
                     σ_r=0.5,
                     a=0.5,
                     b=0.0,
                     σ_z=0.1):

            self.w_hat, self.s_0 = w_hat, s_0
            self.c_y, self.μ_y, self.σ_y = c_y, μ_y, σ_y
            self.c_r, self.μ_r, self.σ_r = c_r, μ_r, σ_r
            self.a, self.b, self.σ_z = a, b, σ_z

            # Record stationary moments
            self.z_mean = b / (1 - a)
            self.z_var = σ_z**2 / (1 - a**2)
            exp_z_mean = np.exp(self.z_mean + self.z_var / 2)
            self.R_mean = c_r * exp_z_mean + np.exp(μ_r + σ_r**2 / 2)
            self.y_mean = c_y * exp_z_mean + np.exp(μ_y + σ_y**2 / 2)

            # Test a stability condition that ensures wealth does not diverge
            # to infinity.
            α = self.R_mean * self.s_0
            if α &gt;= 1:
                raise ValueError(&quot;Stability condition failed.&quot;)

        def parameters(self):
            &quot;&quot;&quot;
            Collect and return parameters.
            &quot;&quot;&quot;
            parameters = (self.w_hat, self.s_0,
                          self.c_y, self.μ_y, self.σ_y,
                          self.c_r, self.μ_r, self.σ_r,
                          self.a, self.b, self.σ_z)
            return parameters

        def update_states(self, w, z):
            &quot;&quot;&quot;
            Update one period, given current wealth w and persistent
            state z.
            &quot;&quot;&quot;

            # Simplify names
            params = self.parameters()
            w_hat, s_0, c_y, μ_y, σ_y, c_r, μ_r, σ_r, a, b, σ_z = params
            zp = a * z + b + σ_z * np.random.randn()

            # Update wealth
            y = c_y * np.exp(zp) + np.exp(μ_y + σ_y * np.random.randn())
            wp = y
            if w &gt;= w_hat:
                R = c_r * np.exp(zp) + np.exp(μ_r + σ_r * np.random.randn())
                wp += R * s_0 * w
            return wp, zp


Here&#39;s function to simulate the time series of wealth for in individual households.

.. code:: ipython3

    @njit
    def wealth_time_series(wdy, w_0, n):
        &quot;&quot;&quot;
        Generate a single time series of length n for wealth given
        initial value w_0.

        The initial persistent state z_0 for each household is drawn from
        the stationary distribution of the AR(1) process.

            * wdy: an instance of WealthDynamics
            * w_0: scalar
            * n: int


        &quot;&quot;&quot;
        z = wdy.z_mean + np.sqrt(wdy.z_var) * np.random.randn()
        w = np.empty(n)
        w[0] = w_0
        for t in range(n-1):
            w[t+1], z = wdy.update_states(w[t], z)
        return w


Now here&#39;s function to simulate a cross section of households forward in time.

Note the use of parallelization to speed up computation.

.. code:: ipython3

    @njit(parallel=True)
    def update_cross_section(wdy, w_distribution, shift_length=500):
        &quot;&quot;&quot;
        Shifts a cross-section of household forward in time

        * wdy: an instance of WealthDynamics
        * w_distribution: array_like, represents current cross-section

        Takes a current distribution of wealth values as w_distribution
        and updates each w_t in w_distribution to w_{t+j}, where
        j = shift_length.

        Returns the new distribution.

        &quot;&quot;&quot;
        new_distribution = np.empty_like(w_distribution)

        # Update each household
        for i in prange(len(new_distribution)):
            z = wdy.z_mean + np.sqrt(wdy.z_var) * np.random.randn()
            w = w_distribution[i]
            for t in range(shift_length-1):
                w, z = wdy.update_states(w, z)
            new_distribution[i] = w
        return new_distribution

Parallelization is very effective in the function above because the time path
of each household can be calculated independently once the path for the
aggregate state is known.




Applications
============

Let&#39;s try simulating the model at different parameter values and investigate
the implications for the wealth distribution.


Time Series
-----------

Let&#39;s look at the wealth dynamics of an individual household.

.. code:: ipython3

    wdy = WealthDynamics()

    ts_length = 200
    w = wealth_time_series(wdy, wdy.y_mean, ts_length)

    fig, ax = plt.subplots()
    ax.plot(w)
    plt.show()

Notice the large spikes in wealth over time.

Such spikes are similar to what we observed in time series when :doc:`we studied Kesten processes &lt;kesten_processes&gt;`.



Inequality Measures
-------------------


Let&#39;s look at how inequality varies with returns on financial assets.

The next function generates a cross section and then computes the Lorenz
curve and Gini coefficient.

.. code:: ipython3

    def generate_lorenz_and_gini(wdy, num_households=100_000, T=500):
        &quot;&quot;&quot;
        Generate the Lorenz curve data and gini coefficient corresponding to a
        WealthDynamics mode by simulating num_households forward to time T.
        &quot;&quot;&quot;
        ψ_0 = np.ones(num_households) * wdy.y_mean
        z_0 = wdy.z_mean

        ψ_star = update_cross_section(wdy, ψ_0, shift_length=T)
        return qe.gini_coefficient(ψ_star), qe.lorenz_curve(ψ_star)

Now we investigate how the Lorenz curves associated with the wealth distribution change as return to savings varies.

The code below plots Lorenz curves for three different values of :math:`\mu_r`.

If you are running this yourself, note that it will take one or two minutes to execute.

This is unavoidable because we are executing a CPU intensive task.

In fact the code, which is JIT compiled and parallelized, runs extremely fast relative to the number of computations.

.. code:: ipython3

    fig, ax = plt.subplots()
    μ_r_vals = (0.0, 0.025, 0.05)
    gini_vals = []

    for μ_r in μ_r_vals:
        wdy = WealthDynamics(μ_r=μ_r)
        gv, (f_vals, l_vals) = generate_lorenz_and_gini(wdy)
        ax.plot(f_vals, l_vals, label=f&#39;$\psi^*$ at $\mu_r = {μ_r:0.2}$&#39;)
        gini_vals.append(gv)

    ax.plot(f_vals, f_vals, label=&#39;equality&#39;)
    ax.legend(loc=&quot;upper left&quot;)
    plt.show()

The Lorenz curve shifts downwards as returns on financial income rise, indicating a rise in inequality.


.. _htop_again:

.. figure:: htop_again.png
   :scale: 80


Now let&#39;s check the Gini coefficient.

.. code:: ipython3

    fig, ax = plt.subplots()
    ax.plot(μ_r_vals, gini_vals, label=&#39;gini coefficient&#39;)
    ax.set_xlabel(&quot;$\mu_r$&quot;)
    ax.legend()
    plt.show()

Once again, we see that inequality increases as returns on financial income
rise.

Let&#39;s finish this section by investigating what happens when we change the
volatility term :math:`\sigma_r` in financial returns.


.. code:: ipython3

    fig, ax = plt.subplots()
    σ_r_vals = (0.35, 0.45, 0.52)
    gini_vals = []

    for σ_r in σ_r_vals:
        wdy = WealthDynamics(σ_r=σ_r)
        gv, (f_vals, l_vals) = generate_lorenz_and_gini(wdy)
        ax.plot(f_vals, l_vals, label=f&#39;$\psi^*$ at $\sigma_r = {σ_r:0.2}$&#39;)
        gini_vals.append(gv)

    ax.plot(f_vals, f_vals, label=&#39;equality&#39;)
    ax.legend(loc=&quot;upper left&quot;)
    plt.show()


We see that greater volatility has the effect of increasing inequality in this model.

.. bibliography:: references.bib
</pre></div>
</div>
</div>
</div>
</div>
</div>


              </div>
              
        
            <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="../develop/test_infrastructure.html" title="上一页 页">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">上一页</p>
            <p class="prev-next-title">Testing Infrastructure</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="wealth_dynamics_rst.html" title="下一页 页">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">下一页</p>
        <p class="prev-next-title">Wealth Distribution Dynamics in rST</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Executable Book Project<br/>
        
            &copy; Copyright 2020, Executable Book Project.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>